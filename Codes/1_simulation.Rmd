---
title: "Simulation_results"
author: "Mona Mousavi"
date: "2023-02-07"
output: html_document
---

# Objective 

+ To see if the cross validation method based on local EONR can select the right model (the best in predicting EONR)
  - local EONR (GAM) vs EONR estaimtes from ML-based methods
+ How do we check whether our method is working or not (comparing with true EONR)

# Preparation

```{r}
source(here::here("GitControlled/Codes/functions/packages.R"))
source(here::here("GitControlled/Codes/functions/internal.R"))
# source(here::here("GitControlled/Codes/Codes/functions/packages.R"))
```

```{r}
cov_list <- c(
  "N", "theta_b2_2", "theta_b2_1", "theta_b1_2", "theta_b1_1", "Nk_2_1", "Nk_2_2",
  "Nk_1_1", "Nk_1_2", "plateau_2_1", "plateau_2_2", "plateau_1_1", "plateau_1_2"
)

cov_list_cf <- c(
  "theta_b2_2", "theta_b2_1", "theta_b1_2", "theta_b1_1", "Nk_2_1", "Nk_2_2",
  "Nk_1_1", "Nk_1_2", "plateau_2_1", "plateau_2_2", "plateau_1_1", "plateau_1_2"
)

raw_data <- readRDS(here::here("Shared/Data/all_sim_data.rds"))

pCorn <- 6.25 / 25.4 # $/kg
pN <- 1 / 0.453592 # $/kg
```


```{r}

sim_single_field <- function(i, num_repeats, num_folds) {
  print(paste0("Working on field ", i))
  # load the data
  data <-
    raw_data[3, ]$reg_data[[1]]$data[[i]] %>%
    # find true EONR
    .[, opt_N := (pN / pCorn - b1) / (2 * b2)] %>%
    .[, opt_N := pmin(Nk, opt_N)] %>%
    .[, opt_N := pmax(0, opt_N)]

  # create spatial data folds
  data_sf <- st_as_sf(data, coords = c("X", "Y"))

  # /*+++++++++++++++++++++++++++++++++++
  #' ## Create folds for cross-validation
  # /*+++++++++++++++++++++++++++++++++++
  num_it <- num_repeats * num_folds

  spatial_folds <- lapply(1:num_repeats, function(n) {
    skcv_folds_try <- spatial_clustering_cv(data_sf, v = num_folds)

    scv_try <-
      skcv_folds_try %>%
      rowwise() %>%
      mutate(
        training_data = list(analysis(splits) %>% data.table()),
        test_data = list(assessment(splits) %>% data.table())
      ) %>%
      mutate(repeats = n)

    return(scv_try)
  }) %>% rbindlist()

  # /*+++++++++++++++++++++++++++++++++++
  #' ## Find local EONR for each fold by method and predict yield
  # /*+++++++++++++++++++++++++++++++++++
  analysis_results_folds <-
    lapply(
      # 1:num_it,
      1:3,
      function(x) analyze_local_all(x, spatial_folds, data)
    )

  #--- RMSE of local EONR (for model selection) ---#
  rmse_local_eonr <-
    purrr::map(analysis_results_folds, "local_eonr_data") %>%
    rbindlist() %>%
    .[, eonr_dif := gam_opt_N_hat - local_opt_N_hat] %>%
    .[, .(rmse_local_eonr = sqrt(mean(eonr_dif^2))), by = method]

  #--- RMSE of yield prediction ---#
  rmse_yield <-
    purrr::map(analysis_results_folds, "yield_hat_data") %>%
    rbindlist() %>%
    .[, yield_dif := yield - yield_hat] %>%
    .[, .(rmse_yield = sqrt(mean(yield_dif^2))), by = method]

  # /*+++++++++++++++++++++++++++++++++++
  #' ## Find site-specific (vra) optimal EONR by method
  # /*+++++++++++++++++++++++++++++++++++
  vra_eonr_hat <- find_vra_whole_all(data)

  #--- Site-specific EONR (for validation) ---#
  rmse_eonr_whole <-
    vra_eonr_hat %>%
    data[, .(aunit_id, opt_N)][., on = "aunit_id"] %>%
    .[, .(rmse_eonr = sqrt(mean((opt_N_hat - opt_N)^2))), by = method]

  data_to_return <-
    rmse_local_eonr %>%
    rmse_yield[., on = "method"] %>%
    rmse_eonr_whole[., on = "method"] %>%
    .[, field_number := i]

  return(data_to_return)
}



##########################################
##########################################
```

# Run simulation
```{r}
num_repeats <- 10
num_folds <- 6

sim_single_field(1, num_repeats, num_folds)

test <-
  mclapply(
    1:10,
    function(x) sim_single_field(x, num_repeats, num_folds),
    mc.cores = detectCores() - 10
  )
```